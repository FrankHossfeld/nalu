# Motivation & Concepts
Based on a discussion at Gitter the idea of creating Nalu was developed.

The main goal was to create a tiny and simple to use application framework with the following characteristics:

* Full support of the browser's back- forward- and reload-button.
* An optional loader that will be executed at application start to load data from the server.
* A client side context, router and event bus which will be automatically injected in every controller. (Handler have only access to the context and the event bus)
* Filters to intercept routing.
* Parameter Constrains 
* History Support by default.
* Separation of views into a controller and a component with framework sided instantiation.
* A controller life-cycle using `start`-, `mayStop`- and `stop`- similar to GWT Activities & Places.
* Supports HTML links and programmatically routing thanks to a router.
* Controller based handler manager, that will remove all handlers from the event bus in case the controller is stopped (handler registrations must be added to the manager).
* UiBinder-Support (nalu-plugin-gwt)
* Composites to support smaller units
* Controller & component caching
* Component creation inside a controller to support GWT replacement rules and static factory methods
* Multi Shell Support
* Tracking Support
* Multi Module Support

Keeping these requirements in mind the implementation of Nalu was started.

## Basic Idea
The basic idea of Nalu is to use a String to route between screens. In the context of a web application this is done using a hash which gets added to the url. Because of the fact that every controller in Nalu is related to a route, Nalu is able to identify controllers, create the controllers and add the controllers to the DOM.

Parameters are also added to the route, so there is no need to create a place (like it is necessary in GWT's Activities & Places). In case Nalu identifies a controller, it will inject the parameters (which are defined by the route definition inside the `@Controller`-annotation) into the controller.

Nalu supports the usage of multiple shells. This is done by adding the shell's name as first part to the route. In case the shell changes, Nalu will look for a shell defined with this name, remove the old one and add the new.

## Comparison: GWT versus Nalu

Let's compare GWT Activities & places with Nalu and see, what are the key differences:


| Feature            | GWT |            Nalu            | 
|--------------------|:---:|:--------------------------:|
| J2CL-Ready         | Yes |            Yes             | 
| MVP-Pattern        | Yes |    [Yes](#MVP-Pattern)     | 
| History-Management | Yes | [Yes](#History-Management) |
| Client-Factory     | Yes |   [Yes](#Client-Factory)   | 
| Filter             | No  |       [Yes](#Filter)       | 
| Component Caching  | No  | [Yes](#Component-Caching)  |
| Tracker            | No  |      [Yes](#Tracker)       | 




### MVP-Pattern
All visual components in Nalu are implementing the MVP-Pattern. The equivalent of the GWT Presenter is in Nalu a **controller** and and the GWT View is the **component**.

You will find this pattern for:
* [Component Controller](https://github.com/NaluKit/nalu/wiki/14.-Controllers-&-Composites#controller)
* [Composite Controller](https://github.com/NaluKit/nalu/wiki/14.-Controllers-&-Composites#composite)
* [Block Controller](https://github.com/NaluKit/nalu/wiki/14.-Controllers-&-Composites#blockcontroller-since-v200)
* [PopUp Controller](https://github.com/NaluKit/nalu/wiki/14.-Controllers-&-Composites#popupcontroller-since-v122)

Nalu controller & components have a similar life cycle like GWT Activities. Nalu and GWT both support a `start`-, `mayStop`- amd `stop`-method.

Nalu also support [component caching](#Component Caching).

### History-Management
GWT and Nalu both support history management. The back-, forward- and reload-button is supported.

Using [GWT](https://www.gwtproject.org/doc/latest/DevGuideMvpActivitiesAndPlaces.html) you have to create an Activity for each screen and a place containing the Tokenizer. Implementing it, requires the implementation of an Ativity and a Place.

Nalu supports history management by default. No need to implement something. In Nalu you don't have Activities nor Places. Nalu uses **routes** to manage history and to navigate. A route in Nalu has all informationen needed to restore a place. The route contains all needed keys and [inject the keys](https://github.com/NaluKit/nalu/wiki/14.-Controllers-&-Composites#parameters) into the controller. All you need to do is to implment a method, that accept a String and annotated it with @AcceptParameter. See: [**Routes**](https://github.com/NaluKit/nalu/wiki/05.-Routes) for more information.

### Client-Factory
In GWT it is a good advice to have a ClientFactory. The advantage of a ClientFactory is to improve DI and to enable different implementation. 

That's something you do not need to worry about in Nalu. The key components of a Nalu application:

* [Router](https://github.com/NaluKit/nalu/wiki/11.-Router) to manage navigation and history
* [Event Bus](https://github.com/NaluKit/nalu/wiki/08.-Eventbus) to handle events
* [Context](https://github.com/NaluKit/nalu/wiki/10.-Context) client sided session store

are automatically injected into every controller, handler, filter, tracker etc. 

### Filter
Nalu supports Filter to intercept a routing. Once a routing (navigation to a new screen) occurs, Nalu will use the filter to check if the routing can be done or not. 

### Component-Caching
Nalu supports [component](https://github.com/NaluKit/nalu/wiki/14.-Controllers-&-Composites#caching) and [composite](https://github.com/NaluKit/nalu/wiki/14.-Controllers-&-Composites#caching) cahching. 

This means, you can reuse components and composites. 





### Tracker
Nalu will call a tracker anytime a routing occurs. This might be helpful in case you want to do something in case a routing occurs. See [Tracking](https://github.com/NaluKit/nalu/wiki/16.-Tracking) for more information.