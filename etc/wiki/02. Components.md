# Components

## Application Interface
The application interface provides basic information about the application. It has to extend ```IsApplication``` and be annotated with ````Application````

The applciaiton interface defines:

   * **shell**: is the shell of the application
   * **context**: is the context of the application
   * **startRoute**: is the route, which will be used, in case the applicaiton is called without a bookmark
   * **loader**: defnies the loader class, which will be called at application start (this parameter is optinal)

 A application interface might look like this one:

 ```Java
@Application(shell = MyShell.class,
             loader = MyApplicationLoader.class,  // is optinal
             startRoute = "/dashboard",
             context = MyApplicationContext.class)
interface MySimpleApplication
  extends IsApplication {
}
 ```


## Entrypoint
The EntryPoint is the star t of your application (in case you are using GWT 2.x). To start the applciaiton you vave to add the following lines:
```Java
 public void onModuleLoad() {
    // Create the application.
    // The ApplicationImpl-class will be generated by the framework.
    MySimpleApplication application = new MySimpleApplicationImpl();
    // start the application by calling the run()-method.
    application.run(new NaluPluginElemental2());
  }
```
You have to tell Nalu which nalu plugin (currently available are a GWT- and a Elemental2-plugin) you would like to use by adding the instance of the plugin as a paramter to the run-method.


### Context
The context can be used to store application wide information (f.e.: such as user name, etc). The instance of the context injected in every filter, handler and controller. This is a good place to store general needed data, f.e.: the user name).

### Component
The component contains the visible part of an component. It can be compared to with a view from the mvp pattern. A component will be autmatically created by the framework and injected to the controller. The use of the component class respects the view delegate pattern.

### Controller
The controller can be cpomapred with the presenter from the mvp pattern. It must be annotated with ```@controller```. The referenced component is created by the framework and injected into the controller.

A controller annotation looks like this:
```java
@Controller(route = "/",
            selector = "content",
             componentInterface = IMyComponent.class,
             component = MyComponent.class)
```
The attributes of the controller annotation are all required.
The attribiutes are:
* **route**: defines the route, which will make the component visible.
* **selector**: defines the place inside the DOM where the component will be added.
* **componentInterface**: is the reference to the component interface
* **component**': is the reference of the component

A route **'/'** inidicates, that the controller will be executed at appilication start.


## Parameters
In case the route has parameters, they have to be added to the route of the controller appoication:
```Java
@Controller(route = "/myRoute/:id",
            selector = 'content',
            componentInterface = IMyComponent.class,
            component = MyComponent.class)
```
To enable parameters, just add: **/:parameterName** at the end of the route. It is possible to have more than one parameter If a route contains a parameter, it is necessary, that the controller implements a method called: ```setParameterName(String value)```.

**The type of the parameter is alwys String.**

You can add as much parameters as you like. Every parameter has to Start with '/:'.


## Controller Lifecycle
Every time a routing happens, a new controller will be created and the ```start```-method is called.
Before the component will be removed from the DOM, the ```mayStop```-method is called. This enables the application to interrupt the routing by routing a non null value. Normally a String is return and will be used as confirmation message in a confirmation dialog.

In case a routing occurs, the stop()-method is called.


## Eventbus
Every Nalu application has a eventbus. This enables the application to fire events. The event bus is injected in every handler and every controller. So you can easily fire events and listen to them.

Nalu uses the event bus from the ```org.gwtproject.events``` artifact which is ready to use with j2cl.


## Filter
To intercept a routing, Nalu offers filters. Filters can be used by adding the @Filter anotation the applicaiton interface.

 ```Java
@Application(shell = MyShell.class,
             loader = MyApplicationLoader.class,  // is optinal
             startRoute = "/dashboard",
             context = MyApplicationContext.class)
@Filters(filterClasses = MyFilter.class)
interface MySimpleApplication
  extends IsApplication {
}
 ```

A filter is triggered by a routing and will be executed before the routing occurs. It can interrupt a routing and redirect to another route. (f.e.: as a LogonFilter)

This is an example of a filter implementation:
```Java

public class MyFilter
  extends AbstractFilter<MyContext> {

  @Override
  public boolean filter(String route,
                        String... parms) {
    if (!user.isLoggoedOn()) {
      return false;
    }
    return true;
  }

  @Override
  public String redirectTo() {
    return "/logon"; // route to 'logon'
  }

  @Override
  public String[] parameters() {
    return new String[]; // we have no parameters
  }
}
```


## Handler
Hadnlers are classes withput a component and can only be triggered by firing events.
Handler are classed (created by the framework at start) that can be used to deal with data, validate, etx. Usually handlers will catch events to get triggered.

### Loader (optional)
A Loader is a class that will be executed at start anables the application to load something from the server.

### Router
The router is injected into the controllers. It enables routing inside the application. Navigation is done by calling:
```
router.route("newRoute", [parameters]);
```

### Shell
iIs the root view, which will be placed into the browser window viewport. The Dom shoudl contain selectors (id) where the childs will be added.
